#Functions to retrieve starting allocations for the ADPROCLUS algorithms
#(i.e. an initial matrix A, so called cluster membership matrix)

#' Generate initial random start
#'
#' Generate an initial random start for the (low dimensional) Additive Profile Clustering
#' algorithm (see \code{\link{adproclus}} and \code{\link{adproclusLD}}).
#'
#' \code{getRandom} generates a random initial binary membership matrix
#' \strong{A} by drawing entries from a Bernoulli Distribution with \eqn{\pi =
#' 0.5}.
#'
#' For generating an initial start from random draws from the data, see \code{\link{getSemiRandom}}
#' For generating an initial start based on a specific set of initial cluster centers, see \code{\link{getRational}}.
#'
#' \strong{Warning:} This function does \emph{not} obtain an ADPRCOLUS model. To
#' perform aditive profile clustering, see \code{\link{adproclus}}.
#'
#' @param data Object-by-variable data matrix of class \code{matrix} or \code{data.frame}.
#' @param nclusters Number of clusters to be used. Must be a positive integer.
#'
#' @return \code{getRandom} returns a list with the following components:
#'   \describe{ \item{\code{type}}{A character string denoting the type of start
#'   ('Random Start')} \item{\code{A}}{A randomly generated initial Membership
#'   matrix}}
#'
#' @export
#'
#' @references Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., & Depril, D.
#' (2010). ADPROCLUS: a graphical user interface for fitting additive profile
#' clustering models to object by variable data matrices. \emph{Behavior
#' Research Methods, 43}(1), 56-65.
#'
#' Depril, D., Van Mechelen, I., & Mirkin, B.
#' (2008). Algorithms for additive clustering of rectangular data tables.
#' \emph{Computational Statistics and Data Analysis, 52,} 4923-4938.
#'
#' Depril, D., Van Mechelen, I., & Wilderjans, T. F.
#' (2012). Lowdimensional additive overlapping clustering.
#' \emph{Journal of classification, 29,} 297-320.
#'
#' @examples
#' start_allocation <- getRandom(ADPROCLUS::CGdata, 3)$A
#'
#' @seealso \code{\link{getSemiRandom}} for generating semi-random starts,
#' \code{\link{getRational}} for generating rational starts and
#' \code{\link{adproclus}}, \code{\link{adproclusLD}} for details about membership and profile matrices.
getRandom <- function(data, nclusters) {
        withr::local_seed(1)

        data <- as.matrix(data)
        checkmate::assertMatrix(data)
        checkmate::assertCount(nclusters, positive = TRUE, coerce = TRUE)
        if (nrow(data) < nclusters) {
                stop("number of clusters cannot exceed number of objects in 'data'")
        }

        k <- nclusters

        n <- nrow(data)

        A <- (matrix(stats::runif(n * k), n, k) < 0.5) * 1
        while (any(colSums(A) == 0) || qr(A)$rank < k) {
                A <- (matrix(stats::runif(n * k), n, k) < 0.5) * 1
        }

        return(list(type = "Random Start", A = A))
}

#' Generate initial semi-random start
#'
#' Generate an initial semi-random start for the (low dimensional) Additive Profile Clustering
#' algorithm (see \code{\link{adproclus}} and \code{\link{adproclusLD}}).
#'
#' An initial cluster membership matrix \eqn{\boldsymbol{A}} is generated by finding the best \eqn{\boldsymbol{A}} conditional
#' on an initial profile matrix
#' \eqn{\boldsymbol{P}} generated by drawing \emph{k} randomly chosen, distinct, rows
#' from \code{data} (for
#' details, see Depril et al., 2012).
#'
#' \strong{Warning:} This function does \emph{not} obtain an ADPRCOLUS model. To
#' perform aditive profile clustering, see \code{\link{adproclus}}.
#'
#' @param data Object-by-variable data matrix of class \code{matrix} or
#'   \code{data.frame}.
#' @param nclusters Number of clusters to be used. Must be a positive integer.
#'
#' @return \code{getSemiRandom} returns a list with the following components:
#'   \describe{
#'   \item{\code{type}}{A character string denoting the type of start
#'   ('Semi-random Start')}
#'   \item{\code{A}}{An initial Membership matrix}}
#'
#' @export
#'
#' @references Wilderjans, T. F., Ceulemans, E., Van Mechelen, I., & Depril, D.
#'   (2010). ADPROCLUS: a graphical user interface for fitting additive profile
#'   clustering models to object by variable data matrices. \emph{Behavior
#'   Research Methods, 43}(1), 56-65.
#'
#'   Depril, D., Van Mechelen, I., & Mirkin, B. (2008). Algorithms for additive
#'   clustering of rectangular data tables. \emph{Computational Statistics and
#'   Data Analysis, 52,} 4923-4938.
#'
#'   #' Depril, D., Van Mechelen, I., & Wilderjans, T. F.
#'   (2012). Lowdimensional additive overlapping clustering.
#'   \emph{Journal of classification, 29,} 297-320.
#'
#' @examples
#' start_allocation <- getSemiRandom(ADPROCLUS::CGdata, 3)$A
#'
#' @seealso \code{\link{getRandom}} for generating random starts,
#' \code{\link{getRational}} for generating rational starts and
#' \code{\link{adproclus}}, \code{\link{adproclusLD}} for details about membership and profile matrices.
getSemiRandom <- function(data, nclusters) {
        withr::local_seed(1)

        data <- as.matrix(data)
        checkmate::assertMatrix(data)
        checkmate::assertCount(nclusters, positive = TRUE, coerce = TRUE)

        if (nrow(data) < nclusters) {
                stop("number of clusters cannot exceed number of objects in 'data'")
        }

        n <- nrow(data)

        rows_selected <- sample(n, nclusters)
        P <- data[rows_selected, ]

        npos <- 2^nclusters
        PossibA <- gtools::permutations(2, nclusters, v = c(0, 1), repeats.allowed = TRUE)
        PossibA <- apply(PossibA, 2, rev)
        if (nclusters > 1) {
                PossibA <- t(apply(PossibA, 1, rev))
        }
        PossibA <- .repmat(PossibA, n, 1)

        replX <- data.frame()
        for (i in 1:n) {
                reps <- matrix(.repmat(data[i, ], npos, 1),
                               ncol = ncol(data), nrow = npos, byrow = TRUE)
                replX <- rbind(replX, reps)
        }
        replX <- as.matrix(replX)

        A <- as.matrix(.updateA_lf2(n, P, replX, PossibA))
        result <- list(type = "Semi-random Start", A = A)
        return(result)
}

#' Generate start allocation based on a priori profiles
#'
#' If cluster profiles are given a priori, this function can be used to compute the conditionally optimal
#' cluster membership matrix A which can then be used as a rational starting allocation for the (low dimensional) ADPROCLUS
#' procedure (see \code{\link{adproclus}} and \code{\link{adproclusLD}}).
#'
#' The function uses the same quadratic loss function and minimization method as the (low dimensional) ADPROCLUS procedure
#' does to find the next conditionally optimal membership matrix A. (for details, see Depril et al., 2012).
#'
#' \strong{Warning:} This function does \emph{not} obtain an ADPRCOLUS model. To
#' perform additive profile clustering, see \code{\link{adproclus}}.
#'
#' @param data Object-by-variable data matrix of class \code{matrix} or
#'   \code{data.frame}.
#' @param starting_profiles A matrix where each row represents the profile values for a cluster
#'
#' @return \code{getRational} returns a list with the following components:
#'   \describe{
#'   \item{\code{type}}{A character string denoting the type of start
#'   ('Rational Start')}
#'   \item{\code{A}}{An initial Membership matrix}}
#' @export
#'
#' @references Depril, D., Van Mechelen, I., & Wilderjans, T. F.
#'   (2012). Lowdimensional additive overlapping clustering.
#'   \emph{Journal of classification, 29,} 297-320.
#'
#' @examples
#' x <- ADPROCLUS::CGdata
#'
#' # Clustering using a user-defined rational start profile matrix (here the first 4 rows of the data)
#' start_allocation <- getRational(x,x[1:4,])$A
#'
#' @seealso \code{\link{getRandom}} for generating random starts,
#' \code{\link{getSemiRandom}} for generating semi-random starts and
#' \code{\link{adproclus}}, \code{\link{adproclusLD}} for details about membership and profile matrices.
getRational <- function(data, starting_profiles) {
        #determine the conditionally optimal A, to be used as a starting allocation in (ld) Adproclus
        #use case: when we have some initial idea about the profile values and thus want one run with
        #seeded on this
        data <- as.matrix(data)
        starting_profiles <- as.matrix(starting_profiles)
        checkmate::assertMatrix(data)
        checkmate::assertMatrix(starting_profiles)
        if(ncol(starting_profiles) != ncol(data)) {
                stop("Number of variables in data must equal number of columns of profile matrix.")
        }

        n <- nrow(data)

        nclusters <- nrow(starting_profiles)
        P <- starting_profiles

        npos <- 2^nclusters
        PossibA <- gtools::permutations(2, nclusters, v = c(0, 1), repeats.allowed = TRUE)
        PossibA <- apply(PossibA, 2, rev)
        if (nclusters > 1) {
                PossibA <- t(apply(PossibA, 1, rev))
        }
        PossibA <- .repmat(PossibA, n, 1)

        replX <- data.frame()
        for (i in 1:n) {
                reps <- matrix(.repmat(data[i, ], npos, 1),
                               ncol = ncol(data), nrow = npos, byrow = TRUE)
                replX <- rbind(replX, reps)
        }
        replX <- as.matrix(replX)

        A <- as.matrix(.updateA_lf2(n, P, replX, PossibA))
        result <- list(type = "Rational Start", A = A)
        return(result)
}
